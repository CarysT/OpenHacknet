using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace Hacknet
{
    internal class SQLExploitExe : ExeModule
    {
        private const float INTRO_TIME = 3f;
        private const float MAIN_INTRO_TIME = 3f;
        private const float MAIN_BODY_TIME = 5f;
        private const float ENDING_TIME = 1.2f;

        public const string initText =
            "Initializing###.#.#.#\nConnecting###.#.#.#.#.#.#.#.#..#.\nInjecting Corrupt Sectors###.#.#.##.#.#.#";

        public const string mainIntrotext = "MEMORY CORRUPTION DETECED\n##Initializing SQL Core Dump##>#>##>#>#>#>>>>>";
        public const string errorIntrotext = "M3^ORK CO3@PI\"} DGT^C.D\n##Ini$$!l^zi/g SQ: -!re 3@Hp##>#>##>#>#>#>>>>>";
        private string[] bodyText;
        private Color brightDrawColor;
        private float currentStateTimer;
        private Color flashColor;
        private float initStringCharDelay = 0.1f;
        private SQLState state;
        private float timeTaken;

        public SQLExploitExe(Rectangle location, OS operatingSystem)
            : base(location, operatingSystem)
        {
            name = "SQLMemoryCorrupter";
            IdentifierName = "SQL Memory Corruption Injector";
            ramCost = 350;
        }

        public override void LoadContent()
        {
            base.LoadContent();
            bodyText = Utils.readEntireFile("Content/EffectFiles/SQLMemoryCorruptionDump.txt").Split(Utils.newlineDelim);
            initStringCharDelay = 3f/
                                  "Initializing###.#.#.#\nConnecting###.#.#.#.#.#.#.#.#..#.\nInjecting Corrupt Sectors###.#.#.##.#.#.#"
                                      .Replace("#", "@@").Length;
            flashColor = os.lockedColor;
            flashColor.A = 0;
            brightDrawColor = os.unlockedColor;
            brightDrawColor.A = 0;
            Programs.getComputer(os, targetIP).hostileActionTaken();
        }

        public override void Update(float t)
        {
            base.Update(t);
            timeTaken += t;
            currentStateTimer += t;
            var sqlState = state;
            updateState();
            if (state == sqlState)
                return;
            currentStateTimer = 0.0f;
        }

        private void updateState()
        {
            var num1 = timeTaken - 3f;
            if (num1 <= 0.0)
            {
                state = SQLState.Intro;
            }
            else
            {
                var num2 = num1 - 3f;
                if (num2 <= 0.0)
                {
                    state = SQLState.MainIntro;
                }
                else
                {
                    var num3 = num2 - 5f;
                    if (num3 <= 0.0)
                        state = SQLState.MainBody;
                    else if (num3 - 1.2f <= 0.0)
                    {
                        state = SQLState.Ending;
                    }
                    else
                    {
                        if (isExiting)
                            return;
                        Completed();
                        isExiting = true;
                    }
                }
            }
        }

        public override void Draw(float t)
        {
            base.Draw(t);
            var empty = Rectangle.Empty;
            drawOutline();
            drawTarget("app:");
            var dest = bounds;
            dest.X += 2;
            dest.Width -= 4;
            dest.Height -= PANEL_HEIGHT + 1;
            dest.Y += PANEL_HEIGHT;
            drawBackground(dest);
            switch (state)
            {
                case SQLState.Intro:
                    drawIntro(dest);
                    break;
                case SQLState.MainIntro:
                    drawMainIntro(dest);
                    break;
                case SQLState.MainBody:
                    drawMainBody(dest);
                    break;
                case SQLState.Ending:
                    drawEnding(dest);
                    break;
            }
        }

        private void drawBackground(Rectangle dest)
        {
            spriteBatch.Draw(Utils.gradient, dest, os.highlightColor*0.2f);
        }

        private void drawIntro(Rectangle dest)
        {
            spriteBatch.DrawString(GuiData.detailfont,
                getDelayDrawString(
                    "Initializing###.#.#.#\nConnecting###.#.#.#.#.#.#.#.#..#.\nInjecting Corrupt Sectors###.#.#.##.#.#.#",
                    -1f), new Vector2(dest.X + 2, dest.Y + 2), Color.White);
        }

        private void drawMainIntro(Rectangle dest)
        {
            if (currentStateTimer < 0.800000011920929)
            {
                if (currentStateTimer%0.200000002980232 < 0.0700000002980232)
                    PatternDrawer.draw(dest, 3f, os.darkBackgroundColor*0.2f, os.lockedColor, spriteBatch,
                        PatternDrawer.binaryTile);
                else
                    spriteBatch.DrawString(GuiData.detailfont,
                        "M3^ORK CO3@PI\"} DGT^C.D\n##Ini$$!l^zi/g SQ: -!re 3@Hp##>#>##>#>#>#>>>>>".Replace("#", ""),
                        new Vector2(dest.X + 2, dest.Y + 2), Color.White);
            }
            else
                spriteBatch.DrawString(GuiData.detailfont,
                    getDelayDrawString("MEMORY CORRUPTION DETECED\n##Initializing SQL Core Dump##>#>##>#>#>#>>>>>",
                        currentStateTimer - 0.8f), new Vector2(dest.X + 2, dest.Y + 2), Color.White);
        }

        private void drawMainBody(Rectangle dest)
        {
            spriteBatch.DrawString(GuiData.detailfont,
                "MEMORY CORRUPTION DETECED\n##Initializing SQL Core Dump##>#>##>#>#>#>>>>>".Replace("#", ""),
                new Vector2(dest.X + 2, dest.Y + 2), Color.White*fade);
            var num1 = (int) (currentStateTimer/5.0*bodyText.Length);
            var num2 = dest.Y + 30;
            var num3 = 6;
            var num4 = (dest.Height - 30)/num3;
            var num5 = 0;
            if (num1 > num4)
                num5 = num1 - num4;
            var position = new Vector2(dest.X + 2, num2);
            for (var index = num5; index < num1; ++index)
            {
                spriteBatch.DrawString(GuiData.detailfont, bodyText[index], position, Color.White, 0.0f, Vector2.Zero,
                    0.5f, SpriteEffects.None, 0.3f);
                position.Y += num3;
            }
        }

        private void drawEnding(Rectangle dest)
        {
            var num = currentStateTimer;
            currentStateTimer = 5f;
            drawMainBody(dest);
            currentStateTimer = num;
            var destinationRectangle = new Rectangle(dest.X, dest.Y + dest.Height/3, dest.Width, dest.Height/3);
            spriteBatch.Draw(Utils.white, destinationRectangle, os.unlockedColor*0.8f);
            destinationRectangle.Height -= 6;
            destinationRectangle.Y += 3;
            spriteBatch.Draw(Utils.white, destinationRectangle, os.indentBackgroundColor*0.8f);
            var text = "UNLOCKED";
            var vector2 = GuiData.font.MeasureString(text);
            var position = new Vector2(destinationRectangle.X + destinationRectangle.Width/2 - vector2.X/2f,
                destinationRectangle.Y + destinationRectangle.Height/2 - vector2.Y/2f);
            spriteBatch.DrawString(GuiData.font, text, position - Vector2.One, brightDrawColor*fade);
            spriteBatch.DrawString(GuiData.font, text, position + Vector2.One, brightDrawColor*fade);
            spriteBatch.DrawString(GuiData.font, text, position, Color.White*fade);
        }

        private string getDelayDrawString(string original, float time = -1f)
        {
            if (time == -1.0)
                time = currentStateTimer;
            var str = "";
            var num = 0.0f;
            for (var index = 0; index < original.Length; ++index)
            {
                num += initStringCharDelay;
                if (original[index] == 35)
                    num += initStringCharDelay;
                if (currentStateTimer >= (double) num && original[index] != 35)
                    str += original[index];
            }
            return str;
        }

        public override void Completed()
        {
            base.Completed();
            var computer = Programs.getComputer(os, targetIP);
            if (computer == null)
                return;
            computer.openPort(1433, os.thisComputer.ip);
        }

        private enum SQLState
        {
            Intro,
            MainIntro,
            MainBody,
            Ending
        }
    }
}