using System;
using System.Collections.Generic;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace Hacknet
{
    internal class HTTPExploitExe : ExeModule
    {
        public static float DURATION = 14f;
        public static float AFTER_COMPLETION_STALL = 1f;
        public static float GRAPH_MOVEMENT = 22f;
        private List<Vector2> backGraphPoints;
        private float fastTimeAccum;
        private List<Vector2> graphPoints;
        private bool hasCompleted;
        private float heightRange;
        private float progress;
        private float sucsessTimer = AFTER_COMPLETION_STALL;
        private float tAccum;

        public HTTPExploitExe(Rectangle location, OS operatingSystem)
            : base(location, operatingSystem)
        {
            needsProxyAccess = true;
            ramCost = 208;
            IdentifierName = "Apache Web Server Worm";
        }

        public override void LoadContent()
        {
            base.LoadContent();
            graphPoints = new List<Vector2>();
            backGraphPoints = new List<Vector2>();
            var num1 = 6f;
            heightRange = (bounds.Height - 4 - 17)/3*2f;
            var num2 = (int) ((bounds.Width - 4)/(double) num1);
            var vector2 = new Vector2(2f, bounds.Height - 4 - 17);
            graphPoints.Add(new Vector2(vector2.X, vector2.Y));
            backGraphPoints.Add(new Vector2(vector2.X, vector2.Y));
            for (var index = 1; index < num2 - 1; ++index)
            {
                graphPoints.Add(new Vector2(vector2.X,
                    vector2.Y - (float) (Utils.random.NextDouble()*0.2 + 0.3)*heightRange));
                backGraphPoints.Add(new Vector2(vector2.X, vector2.Y - (float) Utils.random.NextDouble()*heightRange));
                vector2.X += num1;
            }
            graphPoints.Add(new Vector2(vector2.X, vector2.Y));
            backGraphPoints.Add(new Vector2(vector2.X, vector2.Y));
            var computer = Programs.getComputer(os, targetIP);
            if (computer == null)
                return;
            computer.hostileActionTaken();
        }

        public override void Update(float t)
        {
            base.Update(t);
            tAccum += t*1.5f;
            fastTimeAccum += t*4f;
            progress += t/DURATION;
            if (progress >= 1.0)
            {
                progress = 1f;
                if (!hasCompleted)
                {
                    Completed();
                    hasCompleted = true;
                }
                sucsessTimer -= t;
                if (sucsessTimer > 0.0)
                    return;
                isExiting = true;
            }
            else
            {
                for (var index = 1; index < graphPoints.Count - 1; ++index)
                {
                    var vector2 = graphPoints[index];
                    var num1 = Math.Abs(vector2.Y - heightRange/2f)/(heightRange/2f);
                    var num2 = num1*num1;
                    var num3 = 30f - num2;
                    var num4 = num2*(float) ((1.0 - progress)*num3 + progress*30.0);
                    vector2.Y += (float) Math.Sin(fastTimeAccum + (double) (index*bounds.Width))*GRAPH_MOVEMENT*num4*t;
                    vector2.Y = Math.Min(vector2.Y, bounds.Height);
                    vector2.Y = Math.Max(vector2.Y, 0.0f);
                    graphPoints[index] = vector2;
                    vector2 = backGraphPoints[index];
                    var num5 = heightRange/2f - Math.Abs(vector2.Y - heightRange/2f);
                    vector2.Y += (float) Math.Sin(tAccum + (double) (index*bounds.Width))*GRAPH_MOVEMENT*num5*t;
                    backGraphPoints[index] = vector2;
                }
            }
        }

        public override void Draw(float t)
        {
            base.Draw(t);
            drawOutline();
            drawTarget("app:");
            var destinationRectangle = bounds;
            var vector2_1 = new Vector2(bounds.X, bounds.Y);
            for (var index = 0; index < graphPoints.Count - 1; ++index)
            {
                var vector2_2 = backGraphPoints[index];
                var vector2_3 = backGraphPoints[index + 1];
                vector2_2.Y = Math.Min(vector2_2.Y, bounds.Height);
                vector2_2.Y = Math.Max(vector2_2.Y, 0.0f);
                vector2_3.Y = Math.Min(vector2_3.Y, heightRange);
                vector2_3.Y = Math.Max(vector2_3.Y, 0.0f);
                drawLine(vector2_2 + vector2_1, vector2_3 + vector2_1, os.subtleTextColor);
            }
            for (var index = 0; index < graphPoints.Count - 1; ++index)
                drawLine(graphPoints[index] + vector2_1, graphPoints[index + 1] + vector2_1, Color.White);
            destinationRectangle.X += 2;
            destinationRectangle.Width -= 4;
            destinationRectangle.Y = bounds.Y + bounds.Height - 1 - 13;
            destinationRectangle.Height = 13;
            spriteBatch.Draw(Utils.white, destinationRectangle, os.outlineColor*fade);
            ++destinationRectangle.X;
            ++destinationRectangle.Y;
            destinationRectangle.Width -= 2;
            destinationRectangle.Height -= 2;
            spriteBatch.Draw(Utils.white, destinationRectangle, Color.White*fade);
            destinationRectangle.Width = (int) (destinationRectangle.Width*(double) progress);
            spriteBatch.Draw(Utils.white, destinationRectangle, os.highlightColor*fade);
        }

        public void drawLine(Vector2 origin, Vector2 dest, Color c)
        {
            var y = Vector2.Distance(origin, dest);
            var rotation = (float) Math.Atan2(dest.Y - (double) origin.Y, dest.X - (double) origin.X) + 4.712389f;
            spriteBatch.Draw(Utils.white, origin, new Rectangle?(), c*fade, rotation, Vector2.Zero, new Vector2(1f, y),
                SpriteEffects.None, 0.5f);
        }

        public override void Completed()
        {
            base.Completed();
            var computer = Programs.getComputer(os, targetIP);
            if (computer == null)
                return;
            computer.openPort(80, os.thisComputer.ip);
        }
    }
}